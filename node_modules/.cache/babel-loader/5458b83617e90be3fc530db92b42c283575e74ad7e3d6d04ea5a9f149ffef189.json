{"ast":null,"code":"// actions.js\nimport { SET_LIST_DATA, SET_DESCRIPTION, SET_SHOW_DESCRIPTION } from '../constants/index';\nconsole.log('SET_LIST_DATA:', SET_LIST_DATA);\nconsole.log('SET_DESCRIPTION:', SET_DESCRIPTION);\nconsole.log('SET_SHOW_DESCRIPTION:', SET_SHOW_DESCRIPTION);\n// import {setListData} from \"../slices/taskSlices\";\n\nexport const setListData = data => ({\n  type: SET_LIST_DATA,\n  payload: data\n});\nexport const setDescription = description => ({\n  type: SET_DESCRIPTION,\n  payload: description\n});\nexport const setShowDescription = show => ({\n  type: SET_SHOW_DESCRIPTION,\n  payload: show\n});\nexport const handleDragEnd = (result, dispatch, listData) => {\n  const {\n    source,\n    destination\n  } = result;\n  if (!destination) {\n    return;\n  }\n  if (source.droppableId !== destination.droppableId) {\n    moveBetweenColumns(source, destination, dispatch, listData);\n  } else {\n    moveWithinColumn(source, destination, dispatch, listData);\n  }\n  dispatch(setListData(listData));\n};\nconst moveBetweenColumns = (source, destination, dispatch, listData) => {\n  const sourceListId = source.droppableId;\n  const destinationListId = destination.droppableId;\n\n  // Find the source and destination lists\n  const sourceListIndex = listData.findIndex(ele => ele.id === sourceListId);\n  const destinationListIndex = listData.findIndex(ele => ele.id === destinationListId);\n\n  // Extract the source and destination lists\n  const sourceList = listData[sourceListIndex];\n  const destinationList = listData[destinationListIndex];\n\n  // Clone the task arrays to avoid mutating the original state\n  const sourceTaskList = [...sourceList.task];\n  const destinationTaskList = [...destinationList.task];\n\n  // Remove the item from the source list\n  const [removedItem] = sourceTaskList.splice(source.index, 1);\n\n  // Insert the item into the destination list at the specified index\n  destinationTaskList.splice(destination.index, 0, removedItem);\n\n  // Create the updated list with the modified source and destination lists\n  const updatedList = listData.map((ele, index) => {\n    if (index === sourceListIndex) {\n      return {\n        ...ele,\n        task: sourceTaskList\n      };\n    } else if (index === destinationListIndex) {\n      return {\n        ...ele,\n        task: destinationTaskList\n      };\n    }\n    return ele;\n  });\n\n  // Dispatch the action to update the state\n  dispatch(setListData(updatedList));\n};\nconst moveWithinColumn = (source, destination, dispatch, listData) => {\n  const [sourceCard] = listData.filter(ele => ele.id === source.droppableId);\n  const sourceList = [...sourceCard.task];\n  const [removedList] = sourceList.splice(source.index, 1);\n  sourceList.splice(destination.index, 0, removedList);\n  const updatedList = listData.map(ele => {\n    if (ele.id === source.droppableId) {\n      return {\n        ...ele,\n        task: sourceList\n      };\n    }\n    return ele;\n  });\n  dispatch(setListData(updatedList));\n  localStorage.setItem(\"List\", JSON.stringify(updatedList));\n};","map":{"version":3,"names":["SET_LIST_DATA","SET_DESCRIPTION","SET_SHOW_DESCRIPTION","console","log","setListData","data","type","payload","setDescription","description","setShowDescription","show","handleDragEnd","result","dispatch","listData","source","destination","droppableId","moveBetweenColumns","moveWithinColumn","sourceListId","destinationListId","sourceListIndex","findIndex","ele","id","destinationListIndex","sourceList","destinationList","sourceTaskList","task","destinationTaskList","removedItem","splice","index","updatedList","map","sourceCard","filter","removedList","localStorage","setItem","JSON","stringify"],"sources":["/home/korbendalas/Public/kanban-board-test/src/store/actions/index.js"],"sourcesContent":["// actions.js\nimport { SET_LIST_DATA, SET_DESCRIPTION, SET_SHOW_DESCRIPTION } from '../constants/index';\nconsole.log('SET_LIST_DATA:', SET_LIST_DATA);\nconsole.log('SET_DESCRIPTION:', SET_DESCRIPTION);\nconsole.log('SET_SHOW_DESCRIPTION:', SET_SHOW_DESCRIPTION);\n// import {setListData} from \"../slices/taskSlices\";\n\nexport const setListData = (data) => ({\n    type: SET_LIST_DATA,\n    payload: data,\n});\n\n\nexport const setDescription = (description) => ({\n    type: SET_DESCRIPTION,\n    payload: description,\n});\n\nexport const setShowDescription = (show) => ({\n    type: SET_SHOW_DESCRIPTION,\n    payload: show,\n});\nexport const handleDragEnd = (result, dispatch, listData) => {\n\n    const { source, destination } = result;\n\n    if (!destination) {\n        return;\n    }\n\n    if (source.droppableId !== destination.droppableId) {\n        moveBetweenColumns(source, destination, dispatch, listData);\n    } else {\n        moveWithinColumn(source, destination, dispatch, listData);\n    }\n    dispatch(setListData(listData));\n};\n\nconst moveBetweenColumns = (source, destination, dispatch, listData) => {\n    const sourceListId = source.droppableId;\n    const destinationListId = destination.droppableId;\n\n    // Find the source and destination lists\n    const sourceListIndex = listData.findIndex((ele) => ele.id === sourceListId);\n    const destinationListIndex = listData.findIndex((ele) => ele.id === destinationListId);\n\n    // Extract the source and destination lists\n    const sourceList = listData[sourceListIndex];\n    const destinationList = listData[destinationListIndex];\n\n    // Clone the task arrays to avoid mutating the original state\n    const sourceTaskList = [...sourceList.task];\n    const destinationTaskList = [...destinationList.task];\n\n    // Remove the item from the source list\n    const [removedItem] = sourceTaskList.splice(source.index, 1);\n\n    // Insert the item into the destination list at the specified index\n    destinationTaskList.splice(destination.index, 0, removedItem);\n\n    // Create the updated list with the modified source and destination lists\n    const updatedList = listData.map((ele, index) => {\n        if (index === sourceListIndex) {\n            return { ...ele, task: sourceTaskList };\n        } else if (index === destinationListIndex) {\n            return { ...ele, task: destinationTaskList };\n        }\n        return ele;\n    });\n\n    // Dispatch the action to update the state\n    dispatch(setListData(updatedList));\n};\n\nconst moveWithinColumn = (source, destination, dispatch, listData) => {\n    const [sourceCard] = listData.filter((ele) => ele.id === source.droppableId);\n    const sourceList = [...sourceCard.task];\n    const [removedList] = sourceList.splice(source.index, 1);\n    sourceList.splice(destination.index, 0, removedList);\n    const updatedList = listData.map((ele) => {\n        if (ele.id === source.droppableId) {\n            return { ...ele, task: sourceList };\n        }\n        return ele;\n    });\n    dispatch(setListData(updatedList));\n    localStorage.setItem(\"List\", JSON.stringify(updatedList));\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}